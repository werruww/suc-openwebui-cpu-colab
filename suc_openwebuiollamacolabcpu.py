# -*- coding: utf-8 -*-
"""suc_openwebuiollamacolabcpu.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j9SGRcfJ-bmzujnMXMBVy2MQKG_49iPn
"""

First, I need to think about how to loop in Python. I know there's a way to loop or iterate a set of numbers using a for loop. Maybe using something like for i in range(10): but wait, I just need to print 8 ten times, not a sequence.

Wait, maybe I can use a for loop that runs ten times and prints 8 each time. So, like:

for _ in range(10):
print(8)

for _ in range(10):
print(8)

for _ in range(10):
    print(8)
#print("8")

for _ in range(ÿ≠):
    print(8)

!pip install sqlite3==3.35.0

!pip install open-webui

!open-webui serve

!pip install pyngrok

from pyngrok import ngrok
import threading
import time

ngrok_token = "2qoMyvN33sChLDfKL39OR8IDIxk_2hoKPdPQp4MUdSQbDPv6d"
ngrok.set_auth_token(ngrok_token)

# Start ngrok in a separate thread to avoid blocking
def start_ngrok():
    public_url = ngrok.connect(8080).public_url
    print(f"üöÄ Ngrok Tunnel Open: {public_url}")

ngrok_thread = threading.Thread(target=start_ngrok)
ngrok_thread.start()

# Wait for ngrok to start (optional)
time.sleep(5)

# Execute your node.js script
!open-webui serve

from pyngrok import ngrok
import threading
import time
import os
import subprocess

# --- Configuration ---
NGROK_TOKEN = "2qoMyvN33sChLDfKL39OR8IDIxk_2hoKPdPQp4MUdSQbDPv6d"  # Replace with your token if needed
LOCAL_PORT = 8081 # Choose a different port (e.g., 8081, 8000, 7860)
# --- End Configuration ---

# Set Auth Token
ngrok.set_auth_token(NGROK_TOKEN)

# Global variable to store the public URL
public_url = None
ngrok_process = None

# Start ngrok in a separate thread
def start_ngrok(port):
    global public_url, ngrok_process
    try:
        # Disconnect any existing tunnels before connecting
        # ngrok.disconnect_all() # Often not needed unless debugging leaks
        # time.sleep(1)

        # Start the tunnel
        tunnel = ngrok.connect(port, "http")
        public_url = tunnel.public_url
        print(f"üöÄ Ngrok Tunnel Open: {public_url}")

        # Keep the ngrok process object if needed for later shutdown
        # ngrok_process = ngrok.get_ngrok_process()
        # ngrok_process.proc.wait() # This would block the thread until ngrok exits

    except Exception as e:
        print(f"‚ùå Error starting ngrok: {e}")
        # Attempt cleanup if connection failed partially
        try:
            ngrok.kill()
        except Exception:
            pass # Ignore errors during cleanup attempt


print(f"Attempting to start ngrok on port {LOCAL_PORT}...")
ngrok_thread = threading.Thread(target=start_ngrok, args=(LOCAL_PORT,))
ngrok_thread.daemon = True # Allows main thread to exit even if ngrok thread is running
ngrok_thread.start()

# Wait for ngrok to establish the tunnel and get the URL
print("Waiting for ngrok to start...")
wait_time = 10 # seconds
start_wait = time.time()
while public_url is None and (time.time() - start_wait) < wait_time:
    time.sleep(0.5)

if public_url:
    print(f"Ngrok started successfully: {public_url}")
else:
    print(f"‚ùå Ngrok failed to start within {wait_time} seconds. Check logs.")
    # Optional: exit or raise an error if ngrok is critical
    # exit()

# --- Start Open WebUI on the chosen port ---
print(f"\nStarting Open WebUI on port {LOCAL_PORT}...")

# Use subprocess for better control and error handling than '!'
try:
    # Construct the command
    command = ["open-webui", "serve", "--port", str(LOCAL_PORT)]
    print(f"Executing command: {' '.join(command)}")

    # Start the process
    # Using Popen allows the script to potentially continue or manage the process
    # Use run if you want to wait for it to finish (which might not be desired for a server)
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

    # Stream output
    while True:
        output = process.stdout.readline()
        if output == '' and process.poll() is not None:
            break
        if output:
            print(output.strip())

    # Wait for the process to complete and check return code (optional)
    rc = process.poll()
    print(f"\nOpen WebUI process finished with return code: {rc}")

except FileNotFoundError:
     print(f"‚ùå Error: 'open-webui' command not found. Make sure it's installed and in your PATH.")
except Exception as e:
     print(f"‚ùå An error occurred while running Open WebUI: {e}")
finally:
    # --- Cleanup (Optional but Recommended) ---
    print("\nAttempting to shut down ngrok...")
    try:
        ngrok.kill()
        print("Ngrok shut down.")
    except Exception as e:
        print(f"Error shutting down ngrok: {e}")

    # Wait for the ngrok thread to finish (optional)
    # ngrok_thread.join()

!curl -fsSL https://ollama.com/install.sh | sh

!nohup ollama serve &

!ollama pull llama3.2

!ollama list

from pyngrok import ngrok
import threading
import time
import os
import subprocess

# --- Configuration ---
NGROK_TOKEN = "2qoMyvN33sChLDfKL39OR8IDIxk_2hoKPdPQp4MUdSQbDPv6d"  # Replace with your token if needed
LOCAL_PORT = 8081 # Choose a different port (e.g., 8081, 8000, 7860)
# --- End Configuration ---

# Set Auth Token
ngrok.set_auth_token(NGROK_TOKEN)

# Global variable to store the public URL
public_url = None
ngrok_process = None

# Start ngrok in a separate thread
def start_ngrok(port):
    global public_url, ngrok_process
    try:
        # Disconnect any existing tunnels before connecting
        # ngrok.disconnect_all() # Often not needed unless debugging leaks
        # time.sleep(1)

        # Start the tunnel
        tunnel = ngrok.connect(port, "http")
        public_url = tunnel.public_url
        print(f"üöÄ Ngrok Tunnel Open: {public_url}")

        # Keep the ngrok process object if needed for later shutdown
        # ngrok_process = ngrok.get_ngrok_process()
        # ngrok_process.proc.wait() # This would block the thread until ngrok exits

    except Exception as e:
        print(f"‚ùå Error starting ngrok: {e}")
        # Attempt cleanup if connection failed partially
        try:
            ngrok.kill()
        except Exception:
            pass # Ignore errors during cleanup attempt


print(f"Attempting to start ngrok on port {LOCAL_PORT}...")
ngrok_thread = threading.Thread(target=start_ngrok, args=(LOCAL_PORT,))
ngrok_thread.daemon = True # Allows main thread to exit even if ngrok thread is running
ngrok_thread.start()

# Wait for ngrok to establish the tunnel and get the URL
print("Waiting for ngrok to start...")
wait_time = 10 # seconds
start_wait = time.time()
while public_url is None and (time.time() - start_wait) < wait_time:
    time.sleep(0.5)

if public_url:
    print(f"Ngrok started successfully: {public_url}")
else:
    print(f"‚ùå Ngrok failed to start within {wait_time} seconds. Check logs.")
    # Optional: exit or raise an error if ngrok is critical
    # exit()

# --- Start Open WebUI on the chosen port ---
print(f"\nStarting Open WebUI on port {LOCAL_PORT}...")

# Use subprocess for better control and error handling than '!'
try:
    # Construct the command
    command = ["open-webui", "serve", "--port", str(LOCAL_PORT)]
    print(f"Executing command: {' '.join(command)}")

    # Start the process
    # Using Popen allows the script to potentially continue or manage the process
    # Use run if you want to wait for it to finish (which might not be desired for a server)
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

    # Stream output
    while True:
        output = process.stdout.readline()
        if output == '' and process.poll() is not None:
            break
        if output:
            print(output.strip())

    # Wait for the process to complete and check return code (optional)
    rc = process.poll()
    print(f"\nOpen WebUI process finished with return code: {rc}")

except FileNotFoundError:
     print(f"‚ùå Error: 'open-webui' command not found. Make sure it's installed and in your PATH.")
except Exception as e:
     print(f"‚ùå An error occurred while running Open WebUI: {e}")
finally:
    # --- Cleanup (Optional but Recommended) ---
    print("\nAttempting to shut down ngrok...")
    try:
        ngrok.kill()
        print("Ngrok shut down.")
    except Exception as e:
        print(f"Error shutting down ngrok: {e}")

    # Wait for the ngrok thread to finish (optional)
    # ngrok_thread.join()